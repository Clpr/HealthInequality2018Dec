# <-- encoding UTF-8 -->
# mapplot tools
# --------------------------------
# using ggplot2 to plot maps
# 
# Tianhao Zhao
# Dec 2018
# --------------------------------

# --------------------------------
## ENVIRONMENT
library(ggplot2)  # plotting
library(plyr)  # data manupulating
library(maptools)  # tools to process map data
library(readxl)  # popular excel IO

# --------------------------------
# LOAD MAPSHAPE DATAFILE
MapShapeCH <- maptools::readShapePoly("./data/ChinaMapDat/ChinaMapShape.shp")
# EXTRACT DATA OF ADMINISTRATION AS A DF
df_MapShapeCH_ADM <- data.frame(MapShapeCH@data, id = seq(0:924)-1)  # total 925 shapes including islands
# EXTRACT DATA OF GIS AS A DF
df_MapShapeCH_GIS  <- ggplot2::fortify(MapShapeCH)
# FULL-JOIN THE TWO DFs AS FINAL MAP DATA (TO PLOT)
MapShapeCH <- plyr::join(df_MapShapeCH_GIS, df_MapShapeCH_ADM, type = "full")
# GR (garbage recycling)
rm("df_MapShapeCH_ADM","df_MapShapeCH_GIS")
# -------------------------------
# LOAD THE CITY GIS DATA IN CHINA
# NOTE: saved in xlsx, because Chinese characters used
MapGIScity <- readxl::read_xlsx("./data/ChinaMapDat/GBChinaCountyCityGIS.xlsx")






# --------------------------------
# func: map plotting for province-level data on Chinese (province) map
func_MapProv <- function( vec, vmark, vecName = "data" ){
    # input:
    # 1. vec: a vector, containing numeric data of each province (to plot, greater, depper the color)
    # 2. vmark: a vector of strings, containing (paired) province label; required to be matched with shape files, and ... UNIQUE! (optimal)
    # 3. vecName: a string to indicate the name of the data variable (vec) shown on the final map
    # output:
    # 1. tmpfig: a ggplot object, you may display it or output to PDF through Cairo package (or ggsave() method)
    # dependency:
    # 1. ggplot2
    # 2. MapShapeCH (worksapce var)
    # 3. plyr
    # ------------------
    # 1. create a temp df (where "NAME" is the default name of the province address (in Chinese) in MapShapeCH)
    eval(parse(text=paste(sep="",
        "tmpdf <- data.frame( ", vecName, " = vec, NAME = vmark )"
    )))
    # 2. merge to a df for plotting
    tmpdf <- plyr::join( MapShapeCH, tmpdf, type = "full", by = "NAME" )
    # 3. plot with ggplot2
    eval(parse(text=paste(sep="",
        "tmpfig <- ggplot(tmpdf, aes(x = long, y = lat, group = group, fill = ", vecName, "))"
    )))
    tmpfig <- tmpfig +  geom_polygon(colour="grey40") +
                        scale_fill_gradient(low="white",high="red") +  # gradual coloring, RGB allowed
                        coord_map("polyconic") +       # projection with polyconic method (usual)
                        theme(
                            panel.grid = element_blank(),
                            panel.background = element_blank(),
                            axis.text = element_blank(),
                            axis.ticks = element_blank(),
                            axis.title = element_blank(),
                            legend.position = c(0.2,0.3)
                        )
    # 5. returns
    return(tmpfig)
}

# --------------------------------



# --------------------------------
# func: save maps as PDF figures created by func_MapProv
func_SaveMap2PDF <- function( tmpfig, OutputDir ){
    # input:
    # 1. tmpfig: a ggplot instance, generated by func_MapProv
    # 2. OutputDir: a string directory, including file names
    # output:
    # 1. NULL
    # ------------
    # 1. using ggplot2::ggsave() to save the figure
    ggplot2::ggsave( tmpfig, filename = OutputDir, width = 12, height = 12 )  # inch measures
    return(NULL)
}



# ----------------------------------
# function: project a range [a,b](a,b is real number) to another specific range [x,y]; proportional projection
func_RangeProject <- function( vec, NewRange ){
    # input:
    # 1. vec: a numeric vector, with range [min,max] to project; min,max in the Real-Area, finite
    # 2. NewRange: a 2 element vector, [x,y] to project to; x,y in the Real-Area
    # output:
    # 1. Newvec: a numeric vector with the same size of vec; with min(Newvec) = x, max(Newvec) = y;
    # -----------
    # 0. get min,max;
    tmpmin <- min(vec); tmpmax <- max(vec)
    # 1. first, scale the numbers at min(vec), i.e. [min,max] -> [min,min+y-x ]
    # NOTE: (max-min)/(y-x) = (vec-min)/(Newvec-min)
    Newvec <- vec # a copy
    Newvec <- (NewRange[2]-NewRange[1]) * (vec-tmpmin) / (tmpmax-tmpmin)
    # 2. move to [x,y]
    Newvec <- Newvec + NewRange[1] 
    return(Newvec)
}








# --------------------------------
# function: plot CITY or COUNTY points (x,y paired) on China map
# NOTE: on the map, the values of X is denoted by the depth of color: deeper, larger;
#       and the values of Y is denoted by the diameter of city points: larger, larger;
#       each city in the input dataset is marked as a circle, where the circle is filled with colors with diff depth
func_MapCityXY <- function( vecX, vecY, vlat, vlong, Xname = "x", Yname = "y" , CircleScale = c(2,6), ColorScale = c("white","red"), FontSize = 3  ){
    # input:
    # 1. vecX: a numeric vector of X, len = N
    # 2. vecY: a numeric vector of Y, len = N
    # 3. vmark: a UNIQUE string vector of city names, len=N, matching vecX, vecY
    # 4. vlat: a numeric vector of city latitudes, len = N
    # 5. vlong: a numeric vector of city longitudes, len = N
    # 6. CircleScale: a 2-element vector, controling the size of circles (X values)
    # 7. ColorScale: a 2-element string vector, controling the lowest color & the highest color, e.g. [low,high] -> ["white","red"]
    # output:
    # 1. tmpfig: a ggplot instance which can be plot, edited etc
    # dependency:
    # 1. MapShapeCH: loaded by this script, China province-level shape data
    # -----------
    # 1. a underlying province-level graph
    tmpfig <- ggplot(data = fortify(MapShapeCH)) +  # using preloaded MapShapeCH (chinese province shape data)
        geom_polygon(aes(x = long, y = lat, group = group), colour = "white", fill = "grey80") +  # paint polygons (province shape)
        labs(x = "Longitude", y = "Latitude", hjust = 0.5) +  # axis label
        coord_map() + theme_grey() + theme(plot.title = element_text(hjust = 0.5))  # coord_map() adjust projection to Mercator; using grey theme
    # 2. adjust axis limits to focus on mainland China
    tmpfig <- tmpfig + ggplot2::ylim( 15, 55 )
    # 3. plot city circles (X values) & color (Y values)
        # a temp dataframe
        tmpdf <- data.frame( x = vecX, y = vecY, lat = vlat, long = vlong )
        # add a copy of column "y" but renamed
        tmpdf$y2 <- vecY
        # project X to a specific range (CircleScale)
        tmpdf$vcirclesize <- func_RangeProject( tmpdf$x, CircleScale )
        # project Y to quantile ranges (continuous to discrete, to better distinguish among diff Y values)
        tmpQuant <- quantile(vecY,c(0.0, 0.25, 0.5, 0.75, 1.0))  # requires 0.0 & 1.0
        for(idx in 1:(length(tmpQuant)-1)  ){
            tmpdf$y2[ (tmpQuant[idx] <= tmpdf$y) & (tmpdf$y < tmpQuant[idx+1]) ] <- idx * 2
        }
        tmpdf$y2[ (tmpdf$y == tmpQuant[idx+1]) ] <- length(tmpQuant) * 2
    # 4. painting
    tmpfig <- tmpfig + geom_point(data=tmpdf, aes(x = long, y=lat, group = y2, color = y2  ), shape = 16, size = tmpdf$vcirclesize )  # main plotting
    tmpfig <- tmpfig + labs(color = Yname )  # change the name of color legend/bar
    tmpfig <- tmpfig + scale_colour_gradient( low = ColorScale[1], high = ColorScale[2]  )  # change color scale
    tmpfig <- tmpfig + annotate("text", x=90, y=53, label= paste(sep="","Circle size: ",Xname)   , alpha=.9, size = FontSize  )   # add annotations, alpha is the degree of transparency
    return(tmpfig)
}







































